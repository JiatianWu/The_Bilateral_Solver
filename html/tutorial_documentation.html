<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>My Project: Writing documentation for OpenCV</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Writing documentation for OpenCV </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>#The Fast Bilateral Solver (<b>Still in development</b>)</p>
<p><b>The Bilater Solver</b> is a novel algorithm for edge-aware smoothing that combines the flexibility and speed of simple filtering approaches with the accuracy of domain-specific optimization algorithms. This algorithm was presented by Jonathan T. Barron and Ben Poole as an ECCV2016 oral and best paper nominee. Algorithm details and applications can be found in <a href="https://arxiv.org/pdf/1511.03296.pdf">https://arxiv.org/pdf/1511.03296.pdf</a> .</p>
<hr/>
<hr/>
 <h2>Introduce</h2>
<h3>Algorithm</h3>
<p>We begin by presenting the objective and optimization techniques that make up our bilateral solver. Let us assume that we have some per-pixel input quantities <b>t</b> (the “target” value, see Figure 1a) and some per-pixel confidence of those quantities <b>c</b> (Figure 1c), both represented as vectorized images. Let us also assume that we have some “reference” image (Figure 1d), which is a normal RGB image. Our goal is to recover an “output” vector x (Figure 1b), which will resemble the input target where the confidence is large while being smooth and tightly aligned to edges in the reference image. We will accomplish this by constructing an optimization problem consisting of an image-dependent smoothness term that encourages <b>x</b> to be bilateral-smooth, and a data-fidelity term that minimizes the squared residual between x and the target <b>t</b> weighted by our confidence <b>c</b>: $$minimize{}{2}{i,j}{W}_{i,j}(x_i-x_j)^{2}+{i}(c_i-t_i)^{2}  (1)$$ The smoothness term in this optimization problem is built around an affinity matrix Ŵ , which is a bistochastized version of a bilateral affinity matrix <b>W</b> . Each element of the bilateral affinity matrix $W_{i,j}$ reflects the affinity between pixels i and j in the reference image in the YUV colorspace: $$W_{i,j} = (-{ |[p_i^x,p_i^y]-[[p_j^x,p_j^y]] |}{2{xy}^2}-{(p_i^l-p_j^l)^2}{2{l}^2}-{ |[p_i^u,p_i^v]-[[p_j^u,p_j^v]] |}{2{uv}^2}) (2)$$ Where $p_i$ is a pixel in our reference image with a spatial position $(p_i^x, p_i^y )$ and color $(p_i^l , p_i^u , p_i^v )$. The ${xy} , $ , and $σ_{uv}$ parameters control the extent of the spatial, luma, and chroma support of the filter, respectively. This <b>W</b> matrix is commonly used in the bilateral filter, an edge-preserving filter that blurs within regions but not across edges by locally adapting the filter to the image content. There are techniques for speeding up bilateral filtering which treat the filter as a <b>“splat/blur/slice”</b> procedure: pixel values are “splatted” onto a small set of vertices in a grid or lattice (a soft histogramming operation), then those vertex values are blurred, and then the filtered pixel values are produced via a “slice” (an interpolation) of the blurred vertex values. These splat/blur/slice filtering approaches all correspond to a compact and efficient factorization of <b>W</b> : $$W = S^T{B}S (3)$$ Barron et al. built on this idea to allow for optimization problems to be “splatted” and solved in bilateral-space. They use a “simplified” bilateral grid and a technique for producing bistochastization matrices $D_n , D_m$ that together give the the following equivalences: $${W} = S^TD_m^{-1}D_n{B}D_nD_m^{-1}S , SS^T = D_m (4)$$ They also perform a variable substitution, which reformulates a high-dimensional pixel-space optimization problem in terms of the lower-dimensional bilateral-space vertices: $$x = S^Ty (5)$$ Where y is a small vector of values for each bilateral-space vertex, while x is a large vector of values for each pixel. With these tools we can not only reformulate our pixel-space loss function in Eq 1 in bilateral-space, but we can rewrite that bilateral-space loss function in a quadratic form: $$minimize{1}{2}y^TAy - b^Ty + c (6)$$ $$A = (D_m - D_n{B}D_n) + diag(S c)$$ $$b = S( c   t)$$ $$c = {1}{2}( c   t)^T t$$ where $$ is the Hadamard product. <b>A</b> derivation of this reformulation can be found in the supplement. While the optimization problem in Equation 1 is intractably expensive to solve naively, in this bilateral-space formulation optimization can be performed quickly. Minimizing that quadratic form is equivalent to solving a sparse linear system: $$Ay = b (7)$$ We can produce a pixel-space solution x̂ by simply slicing the solution to that linear system: $${x} = S^T(A^{-1}b)  (8)$$ With this we can describe our algorithm, which we will refer to as the “bilateral solver.” The input to the solver is a reference RGB image, a target image that contains noisy observed quantities which we wish to improve, and a confidence image. We construct a simplified bilateral grid from the reference image, which is bistochastized as in [2] (see the supplement for details), and with that we construct the A matrix and b vector described in Equation 6 which are used to solve the linear system in Equation 8 to produce an output image. If we have multiple target images (with the same reference and confidence images) then we can construct a larger linear system in which b has many columns, and solve for each channel simultaneously using the same A matrix. In this many-target case, if b is low rank then that property can be exploited to accelerate optimization, as we show in the supplement.</p>
<h3>Implementation</h3>
<ul>
<li><b>Splat+Blur+Slice Procedure</b> <div class="image">
<img src="https://raw.githubusercontent.com/THUKey/The_Bilateral_Solver/4cff9dabc9ad48d047f66cc8d68c733a1e403688/build/SBS.png"  alt="SBS"/>
</div>
 The two bilateral representations we use in this project, here shown filtering a toy one-dimensional grayscale image of a step-edge. This toy image corresponds to a 2D space visualized here (x = pixel location, y = pixel value) while in the paper we use RGB images, which corresponds to a 5D space (XYRGB). The lattice (Fig 2a) uses barycen-tric interpolation to map pixels to vertices and requires d+1 blurring operations, where d is the dimensionality of the space. The simplified bilateral grid (Fig 2b) uses nearest-neighbor interpolation and requires d blurring operations which are summed rather than done in sequence. The grid is cheaper to construct and to use than the lattice, but the use of hard assignments means that the filtered output often has blocky piecewise-constant artifacts.</li>
<li><b>Diagrammatize</b> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;st=&gt;start: Start</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;e=&gt;end</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;inr=&gt;operation: Imput reference image</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;int=&gt;operation: Imput target image</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;bg=&gt;operation: construct BilateralGrid</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;sl=&gt;operation: construct SliceMatrix</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;bl=&gt;operation: construct BlurMatrix</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;A1=&gt;operation: construct AMatrix step1</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;A2=&gt;operation: construct AMatrix step2</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;cg=&gt;operation: execute ICCG</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;out=&gt;operation: output the resolt</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;st-&gt;inr-&gt;bg-&gt;sl-&gt;bl-&gt;A1-&gt;int-&gt;A2-&gt;cg-&gt;out-&gt;e</div></div><!-- fragment --></li>
</ul>
<p>###Reference </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;article{BarronPoole2016,</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;author = {Jonathan T Barron and Ben Poole},</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;title = {The Fast Bilateral Solver},</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;journal = {ECCV},</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;year = {2016},</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;@article{Barron2015A,</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;author = {Jonathan T Barron and Andrew Adams and YiChang Shih and Carlos Hern\&#39;andez},</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;title = {Fast Bilateral-Space Stereo for Synthetic Defocus},</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;journal = {CVPR},</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;year = {2015},</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;}</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;@article{Adams2010,</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;author = {Andrew Adams  Jongmin Baek    Abe Davis},</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;title = {Fast High-Dimensional Filtering Using the Permutohedral Lattice},</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;journal = {Eurographics},</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;year = {2010},</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;}</div></div><!-- fragment --> <hr/>
 <h2>Installation Instructions</h2>
<h3>Build OpenCV</h3>
<p>This is just a suggestion on how to build OpenCV 3.1. There a plenty of options. Also some packages might be optional. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;sudo apt-get install libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;git clone https://github.com/Itseez/opencv.git</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;cd opencv</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;mkdir build</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;cd build</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;cmake -D CMAKE_BUILD_TYPE=RELEASE -D WITH_CUDA=OFF ..</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;make -j</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;sudo make install</div></div><!-- fragment --><p>###Build The_Bilateral_Solver </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;git clone https://github.com/THUKey/The_Bilateral_Solver.git</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;cd The_Bilateral_Solver/build</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;cmake ..</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;make</div></div><!-- fragment --><p> This will create three executable demos, that you can run as shown in below.</p>
<h4>Depthsuperresolution</h4>
<div class="image">
<img src="https://raw.githubusercontent.com/THUKey/The_Bilateral_Solver/master/build/target.png"  alt="target"/>
</div>
<p> the target. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;./Depthsuperres</div></div><!-- fragment --> <div class="image">
<img src="https://raw.githubusercontent.com/THUKey/The_Bilateral_Solver/master/build/depthsuperresolution.png"  alt="result"/>
</div>
<p> This result(use bilateral solver) is far from the optimal performance, which means there are some extra work to do, such as to patiently adjustment parameters and to optimize the implementation. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;./Latticefilter reference.png target.png</div></div><!-- fragment --> <div class="image">
<img src="https://raw.githubusercontent.com/THUKey/The_Bilateral_Solver/master/build/lattice_output.png"  alt="enter image description here"/>
</div>
<p> This result(use permutohedral_lattice) is quite nice. ####Colorization </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;./Colorize rose1.webp</div></div><!-- fragment --> <div class="image">
<img src="https://raw.githubusercontent.com/THUKey/The_Bilateral_Solver/master/build/draw.png"  alt="draw"/>
</div>
<p> draw image, then press "ESC" twice to launch the colorization procession. </p><div class="image">
<img src="https://raw.githubusercontent.com/THUKey/The_Bilateral_Solver/master/build/colorized.png"  alt="colorized"/>
</div>
<p> colorized image. you could change the <b>rose1.webp</b> to your own image. Thanks for <a href="https://github.com/timuda/colorization_s_demo">timuda</a>, his colorization implementation help me a lot.</p>
<p>####PermutohedralLatticeFilter </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;./Latticefilter flower8.jpg</div></div><!-- fragment --><p> In Barron's another paper <em>Fast Bilateral-Space Stereo for Synthetic Defocus</em>, both bileteral_solver and permutohedral lattice are used to do experiment, and the result shows that bilateral_solver is faster than permutohedral lattice technique, but the permutohedral is more accurate than the bilateral_solver. In other words, this is the tradeoff between time and accuracy. Actually, both two techniques' tradeoff can be worthwhile in appropriate condition. So I want to implement both two technique for more widely use. </p><div class="image">
<img src="https://raw.githubusercontent.com/THUKey/The_Bilateral_Solver/master/build/lattice_flower8.png"  alt="output"/>
</div>
<p> filter_output. </p><div class="image">
<img src="https://raw.githubusercontent.com/THUKey/The_Bilateral_Solver/master/build/flower8.jpg"  alt="input"/>
</div>
<p> filter_input.</p>
<hr/>
 <h2>Basic Usage</h2>
<p>### Depthsuperresolution: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;BilateralGrid BiGr(mat_R);</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;BiGr.Depthsuperresolution(mat_R,mat_T,sigma_spatial,sigma_luma,sigma_chroma);</div></div><!-- fragment --><p> Firstly, we use the reference image mat_R construct a <a class="el" href="classBilateralGrid.html">BilateralGrid</a>, the we launch a depthsuperresolution to optimize the target image mat_T. The parameter sigma_spatial is the Gaussian kernal for coordinate x y, similarly , the sigma_luma correspond luma(Y) and the sigma_chroma correspond chroma(UV). It need to be noted that he mat_R should be covert to YUV form before construct the bilateralgrid.</p>
<p>###Colorization </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;InputImage InImg(mat_in);</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;mat_bg_in = InImg.get_Image(IMG_YUV);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;InImg.draw_Image();</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;mat_bg_draw_in = InImg.get_Image(IMG_DRAWYUV);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;BilateralGrid BiGr(mat_bg_in);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;BiGr.Colorization(mat_in,mat_bg_draw_in);</div></div><!-- fragment --><p> Similar to above, we need to covert the imput image mat_in(gray image for colorization) to YUV form, then draw the gray image. when the drawing finished, press "ESC" twice to launch the colorization procession. the result will be save in specified folder. ###PermutohedralLattce </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;bilateral(im,spatialSigma,colorSigma);</div></div><!-- fragment --><p> Similar to <a class="el" href="classBilateralGrid.html">BilateralGrid</a>, the PermutohedralLattce also need spatial parameter and the color parameter to specified the Gaussian kernel.</p>
<hr/>
 <h2>Schedule</h2>
<table class="doxtable">
<tr>
<th align="left">Item </th><th align="right">State </th><th align="center">Remark  </th></tr>
<tr>
<td align="left">C++ code of the core algorithm </td><td align="right">Completed </td><td align="center">also python </td></tr>
<tr>
<td align="left">Depthsuperres module </td><td align="right">Completed </td><td align="center">need optimize </td></tr>
<tr>
<td align="left">Colorization module </td><td align="right">Completed </td><td align="center">choose ICCG or others </td></tr>
<tr>
<td align="left">PermutohedralLatticeFilter </td><td align="right">Completed </td><td align="center">increse Compatibility </td></tr>
<tr>
<td align="left">Semantic Segmentation optimizer </td><td align="right">Ongoing </td><td align="center">try apply in CNN </td></tr>
<tr>
<td align="left">Contribute project to OpenCV </td><td align="right">Ongoing </td><td align="center">coding testfile </td></tr>
<tr>
<td align="left">Detail Documentation </td><td align="right">Ongoing </td><td align="center">writing toturial </td></tr>
</table>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
